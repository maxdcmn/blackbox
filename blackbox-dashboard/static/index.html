<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>blackbox</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        /* Theme Variables */
        :root {
            /* Dark Theme (default) */
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --bg-quaternary: #3a3a3a;
            --text-primary: #f5f5f5;
            --text-secondary: #b0b0b0;
            --text-tertiary: #808080;
            --border-primary: #2a2a2a;
            --border-secondary: #3a3a3a;
            --accent-primary: #51cf66;
            --accent-secondary: #40c057;
            --accent-gradient: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.3);
            --shadow-md: 0 4px 15px rgba(0,0,0,0.2);
            --shadow-lg: 0 10px 30px rgba(0,0,0,0.5);

            /* Status Colors */
            --success-bg: #d3f9d8;
            --success-text: #2b8a3e;
            --error-bg: #ffe3e3;
            --error-text: #c92a2a;
            --warning-bg: rgba(255, 107, 107, 0.2);
            --warning-border: #ff6b6b;

            /* Button Colors */
            --btn-primary-bg: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
            --btn-primary-text: #0a0a0a;
            --btn-secondary-bg: #2a2a2a;
            --btn-secondary-text: #b0b0b0;
            --btn-edit-bg: #339af0;
            --btn-delete-bg: #ff6b6b;
            --btn-text-light: white;

            /* Chart Colors */
            --chart-grid: rgba(255, 255, 255, 0.05);
            --chart-text: #666;
            --chart-line-1: #51cf66;
            --chart-line-2: #40c057;
            --chart-line-3: #228be6;
            --chart-line-4: #ff6b6b;
            --chart-line-5: #ffd43b;
            --chart-line-6: #339af0;

            /* Overlay Colors */
            --overlay-light: rgba(255, 255, 255, 0.1);
            --overlay-dark: rgba(0, 0, 0, 0.8);
            --overlay-accent: rgba(81, 207, 102, 0.1);
        }

        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --bg-quaternary: #dee2e6;
            --text-primary: #212529;
            --text-secondary: #495057;
            --text-tertiary: #6c757d;
            --border-primary: #dee2e6;
            --border-secondary: #ced4da;
            --accent-primary: #51cf66;
            --accent-secondary: #40c057;
            --accent-gradient: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
            --shadow-md: 0 4px 15px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 30px rgba(0,0,0,0.15);

            /* Status Colors */
            --success-bg: #d3f9d8;
            --success-text: #2b8a3e;
            --error-bg: #ffe3e3;
            --error-text: #c92a2a;
            --warning-bg: rgba(255, 107, 107, 0.15);
            --warning-border: #ff6b6b;

            /* Button Colors */
            --btn-primary-bg: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
            --btn-primary-text: #0a0a0a;
            --btn-secondary-bg: #e9ecef;
            --btn-secondary-text: #495057;
            --btn-edit-bg: #339af0;
            --btn-delete-bg: #ff6b6b;
            --btn-text-light: white;

            /* Chart Colors */
            --chart-grid: rgba(0, 0, 0, 0.08);
            --chart-text: #666;
            --chart-line-1: #51cf66;
            --chart-line-2: #40c057;
            --chart-line-3: #228be6;
            --chart-line-4: #ff6b6b;
            --chart-line-5: #ffd43b;
            --chart-line-6: #339af0;

            /* Overlay Colors */
            --overlay-light: rgba(0, 0, 0, 0.05);
            --overlay-dark: rgba(0, 0, 0, 0.5);
            --overlay-accent: rgba(81, 207, 102, 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            padding: 40px 20px;
            transition: background-color 0.3s ease;
        }

        .container { max-width: 1400px; margin: 0 auto; }

        .navbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
        }

        .logo {
            height: 60px;
            width: auto;
            display: block;
            transition: opacity 0.3s ease;
        }

        h1 {
            color: var(--text-primary);
            margin: 0;
            font-size: 2.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .nodes-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin-bottom: 20px;
        }

        .node-card {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 30px;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-primary);
            cursor: pointer;
            min-height: 250px;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
        }

        .node-card:hover { transform: translateY(-5px); }

        .node-header { margin-bottom: 15px; }
        .node-name { font-size: 1.5rem; font-weight: 600; color: var(--text-primary); margin-bottom: 8px; }
        .node-status { font-size: 0.85rem; color: var(--text-secondary); }

        .tracking-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            margin-left: 8px;
        }
        .tracking-badge.tracking { background: var(--success-bg); color: var(--success-text); }
        .tracking-badge.not-tracking { background: var(--error-bg); color: var(--error-text); }

        .node-content { display: flex; gap: 30px; flex: 1; }
        .node-stats { flex: 1; display: flex; flex-direction: column; justify-content: center; }

        .utilization-display { text-align: center; margin-bottom: 15px; }
        .utilization-value {
            font-size: 3rem;
            font-weight: 700;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            line-height: 1;
        }
        .utilization-label { font-size: 0.9rem; color: var(--text-secondary); margin-top: 8px; }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: var(--bg-tertiary);
            border-radius: 5px;
            overflow: hidden;
            margin: 12px 0;
        }
        .progress-fill {
            height: 100%;
            background: var(--accent-gradient);
            transition: width 0.5s ease;
        }

        .ratio-display {
            display: flex;
            justify-content: space-around;
            padding-top: 12px;
            border-top: 2px solid var(--border-primary);
        }
        .ratio-item { text-align: center; }
        .ratio-value { font-size: 1.5rem; font-weight: 600; color: var(--accent-primary); }
        .ratio-label { font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px; }

        .node-chart-container { flex: 1; position: relative; }
        .chart-title { font-size: 0.85rem; color: var(--text-secondary); text-align: center; margin-bottom: 8px; }

        .navbar-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .theme-toggle-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 2px solid var(--border-primary);
            padding: 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
        }
        .theme-toggle-btn:hover {
            transform: scale(1.05);
            border-color: var(--accent-primary);
        }
        .theme-toggle-btn svg {
            width: 20px;
            height: 20px;
            fill: var(--text-primary);
            transition: fill 0.3s ease;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }
        .status-indicator.online {
            background: var(--accent-primary);
            box-shadow: 0 0 4px var(--accent-primary);
        }
        .status-indicator.offline {
            background: var(--btn-delete-bg);
            box-shadow: 0 0 4px var(--btn-delete-bg);
        }

        .add-node-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 2px solid var(--border-primary);
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .add-node-btn:hover {
            transform: translateY(-2px);
            border-color: var(--accent-primary);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--overlay-dark);
            z-index: 1000;
            overflow-y: auto;
        }
        .modal.active { display: block; }

        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            margin: 50px auto;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .modal-content.wide { max-width: 95%; }

        .modal-header {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-btn {
            background: var(--bg-tertiary);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            transition: background-color 0.3s ease;
        }
        .close-btn:hover { background: var(--bg-quaternary); }

        .form-group { margin-bottom: 20px; }
        .form-label { display: block; font-size: 0.9rem; font-weight: 500; color: var(--text-secondary); margin-bottom: 8px; }
        .form-input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid var(--border-primary);
            background: var(--bg-primary);
            color: var(--text-primary);
            border-radius: 10px;
            font-size: 1rem;
            transition: border-color 0.3s ease, background-color 0.3s ease;
        }
        .form-input:focus { outline: none; border-color: var(--accent-primary); }

        .form-actions { display: flex; gap: 15px; margin-top: 30px; }
        .btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-primary { background: var(--btn-primary-bg); color: var(--btn-primary-text); }
        .btn-secondary { background: var(--btn-secondary-bg); color: var(--btn-secondary-text); }

        .node-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            margin-bottom: 20px;
            transition: background-color 0.3s ease;
        }
        .node-controls-left { display: flex; gap: 10px; align-items: center; }
        .node-controls-right { display: flex; gap: 10px; }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.9rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .btn-toggle { background: var(--accent-primary); color: var(--btn-text-light); }
        .btn-toggle.disabled { background: var(--btn-delete-bg); }
        .btn-edit { background: var(--btn-edit-bg); color: var(--btn-text-light); }
        .btn-delete { background: var(--btn-delete-bg); color: var(--btn-text-light); }

        .node-status-badge { padding: 6px 12px; border-radius: 6px; font-size: 0.85rem; font-weight: 500; }
        .node-status-badge.enabled { background: var(--success-bg); color: var(--success-text); }
        .node-status-badge.disabled { background: var(--error-bg); color: var(--error-text); }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
        }
        .chart-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 15px;
            padding: 20px;
            transition: opacity 0.15s ease, background-color 0.3s ease, border-color 0.3s ease;
        }
        .chart-box h3 { font-size: 1.1rem; color: var(--text-primary); margin-bottom: 15px; }
        .chart-container { position: relative; height: 300px; transition: opacity 0.15s ease; }

        .message { padding: 15px; border-radius: 10px; text-align: center; margin-bottom: 20px; color: var(--text-primary); }
        .error { background: var(--btn-delete-bg); }
        .success { background: var(--accent-primary); }

        .no-data {
            text-align: center;
            color: var(--text-primary);
            font-size: 1.2rem;
            padding: 60px 20px;
            background: var(--overlay-light);
            border-radius: 20px;
        }

        .refresh-info { text-align: center; color: var(--text-secondary); font-size: 0.9rem; margin-top: 20px; }

        .time-range-selector {
            display: flex;
            align-items: center;
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            margin-bottom: 20px;
            transition: background-color 0.3s ease;
        }

        .time-range-btn {
            padding: 6px 14px;
            margin: 0 4px;
            border: 2px solid var(--border-secondary);
            background: var(--bg-secondary);
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .time-range-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .time-range-btn.active {
            background: var(--accent-gradient);
            border-color: var(--accent-primary);
            color: var(--btn-primary-text);
        }

        .auto-refresh-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--overlay-accent);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .refresh-dot {
            width: 8px;
            height: 8px;
            background: var(--accent-primary);
            border-radius: 50%;
            animation: pulse 5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Chat Interface */
        .chat-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 20px 20px 0 0;
            box-shadow: var(--shadow-lg);
            display: flex;
            flex-direction: column;
            max-height: 600px;
            transition: transform 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
            z-index: 1000;
        }

        .chat-container.minimized {
            transform: translateY(calc(100% - 60px));
        }

        .chat-header {
            background: var(--accent-gradient);
            color: var(--btn-primary-text);
            padding: 15px 20px;
            border-radius: 20px 20px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .chat-header h3 {
            margin: 0;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-toggle-btn {
            background: rgba(0, 0, 0, 0.2);
            border: none;
            color: var(--btn-primary-text);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-toggle-btn:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        .chat-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: var(--bg-primary);
            min-height: 300px;
            max-height: 400px;
        }

        .chat-message {
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .chat-message.user {
            align-items: flex-end;
        }

        .chat-message.assistant {
            align-items: flex-start;
        }

        .chat-bubble {
            max-width: 80%;
            padding: 10px 15px;
            border-radius: 15px;
            word-wrap: break-word;
        }

        .chat-message.user .chat-bubble {
            background: var(--accent-gradient);
            color: var(--btn-primary-text);
        }

        .chat-message.assistant .chat-bubble {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            box-shadow: var(--shadow-sm);
        }

        .chat-loading {
            display: flex;
            gap: 5px;
            padding: 10px;
        }

        .chat-loading span {
            width: 8px;
            height: 8px;
            background: var(--accent-primary);
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .chat-loading span:nth-child(1) { animation-delay: -0.32s; }
        .chat-loading span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        .chat-suggestions {
            padding: 10px 20px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-primary);
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .suggestion-btn {
            padding: 6px 12px;
            background: var(--bg-primary);
            border: 2px solid var(--border-primary);
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-primary);
        }

        .suggestion-btn:hover {
            border-color: var(--accent-primary);
            background: var(--overlay-accent);
        }

        .chat-input-container {
            padding: 15px 20px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-secondary);
            display: flex;
            gap: 10px;
        }

        .chat-input {
            flex: 1;
            padding: 10px 15px;
            border: 2px solid var(--border-secondary);
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 20px;
            font-size: 0.9rem;
            outline: none;
        }

        .chat-input:focus {
            border-color: var(--accent-primary);
        }

        .chat-send-btn {
            background: var(--accent-gradient);
            color: var(--btn-primary-text);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-send-btn:hover {
            transform: scale(1.05);
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .node-selector {
            padding: 10px 20px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-primary);
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            max-height: 120px;
            overflow-y: auto;
        }

        .node-selector-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
            flex-shrink: 0;
        }

        .node-selection-count {
            font-size: 0.75rem;
            color: var(--accent-primary);
            background: var(--overlay-accent);
            padding: 4px 8px;
            border-radius: 10px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .node-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-secondary);
            border-radius: 15px;
            font-size: 0.85rem;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .node-checkbox.selected {
            background: var(--accent-primary);
            color: var(--btn-primary-text);
            border-color: var(--accent-primary);
        }

        .node-checkbox input {
            cursor: pointer;
        }

        .stats-summary {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 10px;
            padding: 20px;
            margin-top: 15px;
            box-shadow: var(--shadow-sm);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .stats-header {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-primary);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--accent-primary);
        }

        /* Node-specific chat in detail modal */
        .detail-chat {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .detail-chat-header {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .detail-chat-body {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
            padding: 15px;
            background: var(--bg-primary);
            border-radius: 10px;
        }

        .detail-chat-input-container {
            display: flex;
            gap: 10px;
        }

        .detail-chat-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }

        /* Cost Estimation */
        .cost-summary {
            background: var(--accent-gradient);
            border-radius: 15px;
            padding: 25px;
            margin-top: 15px;
            color: var(--btn-primary-text);
        }

        .cost-header {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .cost-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .cost-item {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }

        .cost-label {
            font-size: 0.85rem;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .cost-value {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .cost-subtext {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .cost-warning {
            background: var(--warning-bg);
            border-left: 4px solid var(--warning-border);
        }

        .cost-good {
            background: var(--overlay-accent);
            border-left: 4px solid var(--accent-primary);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="navbar">
            <img src="logo-light.png" alt="blackbox" class="logo" id="logoImage">
            <div class="navbar-actions">
                <button class="theme-toggle-btn" onclick="toggleTheme()" id="themeToggle" title="Toggle theme">
                    <svg id="themeIcon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
                <button class="add-node-btn" onclick="openAddModal()">
                    <span style="font-size: 1.5rem;">+</span>
                    <span>Add Node</span>
                </button>
            </div>
        </div>
        <div id="message-container"></div>
        <div id="nodes-container" class="nodes-grid"></div>
        <div class="refresh-info">Auto-refresh every 5 seconds</div>
    </div>

    <!-- Chat Interface -->
    <div class="chat-container" id="chatContainer">
        <div class="chat-header" onclick="toggleChat()">
            <h3>
                <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="margin-right: 8px;">
                    <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/>
                </svg>
                AI Assistant
            </h3>
            <button class="chat-toggle-btn" id="chatToggleBtn">−</button>
        </div>

        <div class="node-selector" id="nodeSelector">
            <span class="node-selector-label">Analyze:</span>
            <label class="node-checkbox selected" id="allNodesCheckbox">
                <input type="checkbox" checked onchange="toggleAllNodes(this)"> All Nodes
            </label>
            <span class="node-selection-count" id="nodeSelectionCount" style="display: none;"></span>
            <div id="nodeSelectorList" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
        </div>

        <div class="chat-suggestions" id="chatSuggestions">
            <button class="suggestion-btn" onclick="askQuestion('What does my KV-cache utilization tell me?')">
                KV-cache analysis
            </button>
            <button class="suggestion-btn" onclick="askQuestion('What are your recommendations?')">
                Get recommendations
            </button>
            <button class="suggestion-btn" onclick="askQuestion('Are there any performance issues?')">
                Performance check
            </button>
            <button class="suggestion-btn" onclick="askQuestion('Explain memory fragmentation')">
                Memory status
            </button>
        </div>

        <div class="chat-body" id="chatBody">
            <div class="chat-message assistant">
                <div class="chat-bubble">
                    Hi! I can analyze your GPU metrics and answer questions about KV-cache utilization, memory usage, and performance. Try one of the suggestions below or ask me anything!
                </div>
            </div>
        </div>

        <div class="chat-input-container">
            <input
                type="text"
                class="chat-input"
                id="chatInput"
                placeholder="Ask about your GPU metrics..."
                onkeypress="if(event.key==='Enter') sendMessage()"
            >
            <button class="chat-send-btn" id="chatSendBtn" onclick="sendMessage()">➤</button>
        </div>
    </div>

    <!-- Add Node Modal -->
    <div id="addNodeModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>Add New Node</span>
                <button class="close-btn" onclick="closeAddModal()">&times;</button>
            </div>
            <div id="add-message"></div>
            <form onsubmit="handleAddNode(event)">
                <div class="form-group">
                    <label class="form-label">Node Name</label>
                    <input type="text" id="nodeName" class="form-input" placeholder="e.g., gpu-server-1" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Host</label>
                    <input type="text" id="nodeHost" class="form-input" placeholder="e.g., 192.168.1.100" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Port</label>
                    <input type="number" id="nodePort" class="form-input" value="6767" required>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeAddModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Add Node</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Detail Modal -->
    <div id="detailModal" class="modal">
        <div class="modal-content wide">
            <div class="modal-header">
                <span id="detailNodeName">Node Details</span>
                <button class="close-btn" onclick="closeDetailModal()">&times;</button>
            </div>
            <div id="detailContent"></div>
        </div>
    </div>

    <script>
        const API_BASE = '/api';
        const REFRESH_INTERVAL = 5000;  // 5 seconds

        let nodes = [];
        let charts = {};
        let detailCharts = {};

        // === THEME MANAGEMENT ===
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';

            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);

            // Update icon - moon for dark mode, sun for light mode
            const icon = document.getElementById('themeIcon');
            if (newTheme === 'light') {
                // Sun icon
                icon.innerHTML = '<circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>';
            } else {
                // Moon icon
                icon.innerHTML = '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>';
            }

            // Update logo
            const logo = document.getElementById('logoImage');
            logo.src = newTheme === 'light' ? 'logo-dark.png' : 'logo-light.png';

            // Refresh all charts to pick up new theme colors
            setTimeout(() => {
                // Refresh detail charts if modal is open
                Object.keys(detailCharts).forEach(chartId => {
                    const chart = detailCharts[chartId];
                    if (chart) {
                        const gridColor = getCSSVar('--chart-grid');
                        const textColor = getCSSVar('--chart-text');
                        chart.options.scales.x.grid.color = gridColor;
                        chart.options.scales.x.ticks.color = textColor;
                        chart.options.scales.y.grid.color = gridColor;
                        chart.options.scales.y.ticks.color = textColor;
                        chart.update();
                    }
                });
            }, 50);

            console.log(`[Theme] Switched to ${newTheme} mode`);
        }

        // Load saved theme on page load
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            const html = document.documentElement;

            if (savedTheme === 'light') {
                html.setAttribute('data-theme', 'light');
                const icon = document.getElementById('themeIcon');
                const logo = document.getElementById('logoImage');
                // Sun icon
                if (icon) icon.innerHTML = '<circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>';
                if (logo) logo.src = 'logo-dark.png';
            } else {
                const logo = document.getElementById('logoImage');
                if (logo) logo.src = 'logo-light.png';
                // Moon icon is default
            }

            console.log(`[Theme] Loaded ${savedTheme} mode`);
        }

        // Load theme immediately
        loadTheme();

        // Helper function to get CSS variable value
        function getCSSVar(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        }

        let refreshTimer = null;
        let detailRefreshTimer = null;
        let currentNode = null;
        let currentTimeRange = 3600; // Default: 1 hour in seconds

        // === DATA FETCHING ===
        async function fetchNodes() {
            const res = await fetch(`${API_BASE}/nodes`);
            return res.ok ? await res.json() : [];
        }

        async function fetchSnapshot(nodeId) {
            const res = await fetch(`${API_BASE}/snapshots/latest?node_id=${nodeId}`);
            return res.ok ? await res.json() : null;
        }

        async function fetchTimeseries(nodeId, metric, duration = currentTimeRange) {
            const res = await fetch(`${API_BASE}/timeseries/${metric}?node_id=${nodeId}&duration=${duration}`);
            const data = res.ok ? await res.json() : [];
            console.log(`[fetchTimeseries] ${metric} for node ${nodeId} (${duration}s): ${data.length} points`);
            if (data.length > 0) {
                console.log('  First point:', data[0]);
                console.log('  Last point:', data[data.length - 1]);
                console.log('  Time range:', new Date(data[0].timestamp).toLocaleTimeString(), '→', new Date(data[data.length - 1].timestamp).toLocaleTimeString());
            }
            return data;
        }

        async function fetchNodeStats(nodeId, duration = currentTimeRange) {
            try {
                const [kvData, memData, fragData] = await Promise.all([
                    fetchTimeseries(nodeId, 'kv_cache_utilization', duration),
                    fetchTimeseries(nodeId, 'vllm_memory_utilization', duration),
                    fetchTimeseries(nodeId, 'memory_fragmentation', duration)
                ]);

                if (kvData.length === 0) return null;

                const kvValues = kvData.map(d => d.value);
                const memValues = memData.map(d => d.value);
                const fragValues = fragData.map(d => d.value);

                return {
                    kv_avg: kvValues.reduce((a, b) => a + b, 0) / kvValues.length,
                    kv_max: Math.max(...kvValues),
                    kv_min: Math.min(...kvValues),
                    mem_avg: memValues.reduce((a, b) => a + b, 0) / memValues.length,
                    mem_max: Math.max(...memValues),
                    mem_min: Math.min(...memValues),
                    frag_avg: fragValues.reduce((a, b) => a + b, 0) / fragValues.length,
                    frag_max: Math.max(...fragValues),
                    count: kvData.length
                };
            } catch (error) {
                console.error('Error fetching stats:', error);
                return null;
            }
        }

        // === UTILITIES ===
        function showMessage(msg, type = 'error') {
            const container = document.getElementById('message-container');
            container.innerHTML = `<div class="message ${type}">${msg}</div>`;
            setTimeout(() => container.innerHTML = '', 5000);
        }

        function formatTime(timestamp) {
            const diff = Math.floor((Date.now() - new Date(timestamp)) / 1000);
            if (diff < 60) return `${diff}s ago`;
            if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
            return new Date(timestamp).toLocaleTimeString();
        }

        function getTimeRangeLabel(duration) {
            if (duration === 300) return '5 minutes';
            if (duration === 3600) return '1 hour';
            if (duration === 10800) return '3 hours';
            if (duration === 21600) return '6 hours';
            if (duration === 43200) return '12 hours';
            if (duration === 86400) return '24 hours';
            if (duration === 604800) return '7 days';
            return `${duration}s`;
        }

        function calcUtilization(snapshot) {
            if (!snapshot) return { util: 0, utilized: 0, allocated: 0 };
            return {
                util: snapshot.kv_cache_utilization || 0,
                utilized: snapshot.utilized_blocks || 0,
                allocated: snapshot.allocated_blocks || 0
            };
        }

        // Cost estimation: ~$1 per 40GB VRAM per hour
        async function calculateCosts(nodeId, timeRange) {
            const GB = 1024 * 1024 * 1024;
            const MB = 1024 * 1024;
            const COST_PER_40GB_PER_HOUR = 1.0; // $1 per 40GB per hour
            const HOURS_PER_MONTH = 730; // Average hours in a month

            // Get current snapshot for total_bytes and block size
            const snapshot = await fetchSnapshot(nodeId);
            if (!snapshot) return null;

            // Determine actual block size from the snapshot data
            // We can calculate this from: atomic_allocations_bytes / allocated_blocks
            // Or fetch it from the /vram endpoint's block data
            let blockSizeBytes = null;

            if (snapshot.atomic_allocations_bytes && snapshot.allocated_blocks > 0) {
                // Calculate actual block size from the data
                blockSizeBytes = Math.round(snapshot.atomic_allocations_bytes / snapshot.allocated_blocks);
            }

            // Fallback to fetching detailed snapshot if needed
            if (!blockSizeBytes) {
                try {
                    const detailResponse = await fetch(`${API_BASE}/snapshots/${snapshot.id}`);
                    if (detailResponse.ok) {
                        const detail = await detailResponse.json();
                        if (detail.blocks && detail.blocks.length > 0) {
                            // Use the size from the first block (all blocks should be same size)
                            blockSizeBytes = detail.blocks[0].size;
                        }
                    }
                } catch (e) {
                    console.warn('Could not fetch block size details:', e);
                }
            }

            // Final fallback to reasonable estimate if we still don't have it
            if (!blockSizeBytes) {
                blockSizeBytes = 32 * MB; // Conservative estimate
            }

            // Get timeseries data for the selected time range
            const [memData, allocatedData, utilizedData, freeData] = await Promise.all([
                fetchTimeseries(nodeId, 'used_bytes', timeRange),
                fetchTimeseries(nodeId, 'allocated_blocks', timeRange),
                fetchTimeseries(nodeId, 'utilized_blocks', timeRange),
                fetchTimeseries(nodeId, 'free_blocks', timeRange)
            ]);

            if (memData.length === 0) return null;

            // Calculate averages over the time range
            const avgUsedBytes = memData.reduce((a, b) => a + b.value, 0) / memData.length;
            const avgAllocatedBlocks = allocatedData.reduce((a, b) => a + b.value, 0) / allocatedData.length;
            const avgUtilizedBlocks = utilizedData.reduce((a, b) => a + b.value, 0) / utilizedData.length;
            const avgFreeBlocks = freeData.reduce((a, b) => a + b.value, 0) / freeData.length;

            const totalGB = snapshot.total_bytes / GB;
            const avgUsedGB = avgUsedBytes / GB;
            const avgUnusedGB = totalGB - avgUsedGB; // Completely unused VRAM

            // Calculate ACTUAL KV-cache memory usage using real block size
            const avgKvCacheAllocatedBytes = avgAllocatedBlocks * blockSizeBytes;
            const avgKvCacheUtilizedBytes = avgUtilizedBlocks * blockSizeBytes;
            const avgKvCacheWastedBytes = avgFreeBlocks * blockSizeBytes;

            const avgKvCacheAllocatedGB = avgKvCacheAllocatedBytes / GB;
            const avgKvCacheWastedGB = avgKvCacheWastedBytes / GB;

            // Calculate time range in hours
            const timeRangeHours = timeRange / 3600;

            // Costs for the selected time period
            const totalCostForPeriod = (totalGB / 40) * COST_PER_40GB_PER_HOUR * timeRangeHours;

            // Unused VRAM cost (completely idle memory)
            const unusedMemoryCostForPeriod = (avgUnusedGB / 40) * COST_PER_40GB_PER_HOUR * timeRangeHours;

            // KV-cache waste cost (allocated but unutilized blocks)
            const kvWasteCostForPeriod = (avgKvCacheWastedGB / 40) * COST_PER_40GB_PER_HOUR * timeRangeHours;

            // Total waste
            const totalWasteCostForPeriod = unusedMemoryCostForPeriod + kvWasteCostForPeriod;

            // Project to monthly costs
            const totalCostPerMonth = (totalGB / 40) * COST_PER_40GB_PER_HOUR * HOURS_PER_MONTH;
            const unusedMemoryCostPerMonth = (avgUnusedGB / 40) * COST_PER_40GB_PER_HOUR * HOURS_PER_MONTH;
            const kvWasteCostPerMonth = (avgKvCacheWastedGB / 40) * COST_PER_40GB_PER_HOUR * HOURS_PER_MONTH;
            const totalWastePerMonth = unusedMemoryCostPerMonth + kvWasteCostPerMonth;

            // KV-cache efficiency
            const kvEfficiencyPercent = avgAllocatedBlocks > 0
                ? (avgUtilizedBlocks / avgAllocatedBlocks) * 100
                : 0;

            return {
                // Period costs
                totalCostForPeriod: totalCostForPeriod,
                totalWasteCostForPeriod: totalWasteCostForPeriod,
                unusedMemoryCostForPeriod: unusedMemoryCostForPeriod,
                kvWasteCostForPeriod: kvWasteCostForPeriod,
                timeRangeHours: timeRangeHours,

                // Monthly projections
                totalCostPerMonth: totalCostPerMonth,
                unusedMemoryCostPerMonth: unusedMemoryCostPerMonth,
                kvWasteCostPerMonth: kvWasteCostPerMonth,
                totalWastePerMonth: totalWastePerMonth,

                // Efficiency metrics
                utilizationPercent: (avgUsedGB / totalGB) * 100,
                kvEfficiencyPercent: kvEfficiencyPercent,

                // Memory stats
                totalGB: totalGB,
                avgUsedGB: avgUsedGB,
                avgUnusedGB: avgUnusedGB,
                avgKvCacheAllocatedGB: avgKvCacheAllocatedGB,
                avgKvCacheWastedGB: avgKvCacheWastedGB,

                // Meta
                blockSizeBytes: blockSizeBytes,
                blockSizeMB: (blockSizeBytes / MB).toFixed(2)
            };
        }

        // === CHART CREATION ===
        function createOrUpdateChart(canvasId, data, color = null) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            // Use CSS variable if color not specified
            if (!color) color = getCSSVar('--chart-line-1');

            console.log(`[createOrUpdateChart] ${canvasId}: rendering ${data.length} points`);

            const now = new Date();
            const oneHourAgo = new Date(now - 3600 * 1000);

            if (charts[canvasId]) {
                charts[canvasId].data.labels = data.map(d => new Date(d.timestamp));
                charts[canvasId].data.datasets[0].data = data.map(d => d.value);
                // Update time axis to show current hour window
                charts[canvasId].options.scales.x.min = oneHourAgo;
                charts[canvasId].options.scales.x.max = now;
                charts[canvasId].update('none');
                console.log(`[createOrUpdateChart] ${canvasId}: updated with ${data.length} points`);
                return;
            }

            console.log(`[createOrUpdateChart] ${canvasId}: creating new chart with ${data.length} points`);

            const gridColor = getCSSVar('--chart-grid');
            const textColor = getCSSVar('--chart-text');

            charts[canvasId] = new Chart(canvas, {
                type: 'line',
                data: {
                    labels: data.map(d => new Date(d.timestamp)),
                    datasets: [{
                        data: data.map(d => d.value),
                        borderColor: color,
                        backgroundColor: color + '33',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: ctx => `${ctx.parsed.y.toFixed(1)}%`
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: oneHourAgo,
                            max: now,
                            time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } },
                            grid: { color: gridColor },
                            ticks: { color: textColor, font: { size: 11 } }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            grid: { color: gridColor },
                            ticks: {
                                color: textColor,
                                font: { size: 11 },
                                callback: v => v + '%'
                            }
                        }
                    }
                }
            });
        }

        // === NODE CARD RENDERING ===
        function createNodeCardHTML(node) {
            return `
                <div class="node-card" onclick="openDetail(${node.id}, '${node.name}')" data-node-id="${node.id}">
                    <div class="node-header">
                        <div class="node-name">
                            <span data-name>${node.name}</span>
                            <span data-badge class="tracking-badge not-tracking">Loading...</span>
                        </div>
                        <div class="node-status" data-status>
                            🔴 Offline • ${node.host}:${node.port}
                        </div>
                    </div>
                    <div class="node-content">
                        <div class="node-stats">
                            <div class="utilization-display">
                                <div class="utilization-value" data-util>0.0%</div>
                                <div class="utilization-label">KV-Cache Utilization</div>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" data-progress style="width: 0%"></div>
                            </div>
                            <div class="ratio-display">
                                <div class="ratio-item">
                                    <div class="ratio-value" data-utilized>0</div>
                                    <div class="ratio-label">Utilized Blocks</div>
                                </div>
                                <div class="ratio-item">
                                    <div class="ratio-value" data-active>0</div>
                                    <div class="ratio-label">Allocated Blocks</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function updateNodeCard(card, node, snapshot) {
            const { util, utilized, allocated } = calcUtilization(snapshot);

            // Update tracking badge
            const badge = card.querySelector('[data-badge]');
            if (node.enabled) {
                if (snapshot) {
                    badge.textContent = 'Tracking';
                    badge.className = 'tracking-badge tracking';
                } else {
                    badge.textContent = 'Waiting...';
                    badge.className = 'tracking-badge not-tracking';
                }
            } else {
                badge.textContent = 'Disabled';
                badge.className = 'tracking-badge not-tracking';
            }

            // Update status
            const status = card.querySelector('[data-status]');
            const isOnline = snapshot && node.enabled;
            status.innerHTML = `
                <span class="status-indicator ${isOnline ? 'online' : 'offline'}"></span>${isOnline ? 'Online' : 'Offline'} • ${node.host}:${node.port}
                ${snapshot ? ` • ${formatTime(snapshot.timestamp)}` : ''}
            `;

            // Update metrics
            card.querySelector('[data-util]').textContent = `${util.toFixed(1)}%`;
            card.querySelector('[data-progress]').style.width = `${util}%`;
            card.querySelector('[data-utilized]').textContent = utilized;
            card.querySelector('[data-active]').textContent = allocated;
        }

        // === UPDATE FUNCTIONS ===
        async function updateDashboard() {
            nodes = await fetchNodes();
            const container = document.getElementById('nodes-container');

            if (nodes.length === 0) {
                container.innerHTML = '<div class="no-data">No nodes configured. Click + to add a node.</div>';
                return;
            }

            const existingNodeIds = new Set(
                Array.from(container.querySelectorAll('[data-node-id]')).map(el => parseInt(el.dataset.nodeId))
            );
            const currentNodeIds = new Set(nodes.map(n => n.id));

            // Check if we need to rebuild (nodes added/removed)
            const needsRebuild = existingNodeIds.size !== currentNodeIds.size ||
                                 ![...currentNodeIds].every(id => existingNodeIds.has(id));

            if (needsRebuild) {
                // Complete rebuild
                container.innerHTML = nodes.map(n => createNodeCardHTML(n)).join('');

                // Update all cards
                for (const node of nodes) {
                    const card = container.querySelector(`[data-node-id="${node.id}"]`);
                    const snapshot = await fetchSnapshot(node.id);
                    updateNodeCard(card, node, snapshot);
                }
            } else {
                // Just update existing cards
                for (const node of nodes) {
                    const card = container.querySelector(`[data-node-id="${node.id}"]`);
                    if (!card) continue;

                    const snapshot = await fetchSnapshot(node.id);
                    updateNodeCard(card, node, snapshot);
                }
            }
        }

        // === NODE DETAIL ===
        async function openDetail(nodeId, nodeName) {
            console.log(`[openDetail] Opening detail for node ${nodeId} (${nodeName})`);

            const res = await fetch(`${API_BASE}/nodes/${nodeId}`);
            if (!res.ok) return showMessage('Failed to load node details');

            currentNode = await res.json();
            document.getElementById('detailNodeName').textContent = `${nodeName} - Details`;
            document.getElementById('detailModal').classList.add('active');

            const metrics = [
                { key: 'kv_cache_utilization', title: 'KV-Cache Utilization (%)', color: getCSSVar('--chart-line-1') },
                { key: 'vllm_memory_utilization', title: 'vLLM Memory Utilization (%)', color: getCSSVar('--chart-line-2') },
                { key: 'allocated_blocks', title: 'Allocated Blocks (Total)', color: getCSSVar('--chart-line-1') },
                { key: 'utilized_blocks', title: 'Utilized Blocks (In Use)', color: getCSSVar('--chart-line-3') },
                { key: 'memory_fragmentation', title: 'Memory Fragmentation', color: getCSSVar('--chart-line-4') },
                { key: 'used_bytes', title: 'Used Memory (Bytes)', color: getCSSVar('--chart-line-5') },
                { key: 'num_processes', title: 'Number of Processes', color: getCSSVar('--chart-line-6') }
            ];

            // Fetch stats for average calculation
            const statsData = await fetchNodeStats(nodeId, currentTimeRange);

            // Calculate costs based on time range
            const costs = await calculateCosts(nodeId, currentTimeRange);

            const controls = `
                <div style="position: relative;">
                    <div class="auto-refresh-indicator">
                        <div class="refresh-dot"></div>
                        <span>Auto-refresh: 5s</span>
                    </div>
                    <div class="node-controls">
                        <div class="node-controls-left">
                            <span class="node-status-badge ${currentNode.enabled ? 'enabled' : 'disabled'}">
                                ${currentNode.enabled ? 'Enabled' : 'Disabled'}
                            </span>
                            <span style="color: #666;">${currentNode.host}:${currentNode.port}</span>
                        </div>
                        <div class="node-controls-right">
                            <button class="btn-small btn-toggle ${!currentNode.enabled ? 'disabled' : ''}" onclick="toggleNode()">
                                ${currentNode.enabled ? 'Disable' : 'Enable'} Tracking
                            </button>
                            <button class="btn-small btn-edit" onclick="editNode()">Edit</button>
                            <button class="btn-small btn-delete" onclick="deleteNode()">Delete</button>
                        </div>
                    </div>
                    <div class="time-range-selector">
                        <span style="color: #666; margin-right: 10px; font-weight: 500;">Time Range:</span>
                        <button class="time-range-btn ${currentTimeRange === 300 ? 'active' : ''}" onclick="changeTimeRange(300)">5m</button>
                        <button class="time-range-btn ${currentTimeRange === 3600 ? 'active' : ''}" onclick="changeTimeRange(3600)">1h</button>
                        <button class="time-range-btn ${currentTimeRange === 10800 ? 'active' : ''}" onclick="changeTimeRange(10800)">3h</button>
                        <button class="time-range-btn ${currentTimeRange === 21600 ? 'active' : ''}" onclick="changeTimeRange(21600)">6h</button>
                        <button class="time-range-btn ${currentTimeRange === 43200 ? 'active' : ''}" onclick="changeTimeRange(43200)">12h</button>
                        <button class="time-range-btn ${currentTimeRange === 86400 ? 'active' : ''}" onclick="changeTimeRange(86400)">24h</button>
                        <button class="time-range-btn ${currentTimeRange === 604800 ? 'active' : ''}" onclick="changeTimeRange(604800)">7d</button>
                    </div>
                    ${statsData ? `
                    <div class="stats-summary">
                        <div class="stats-header">
                            <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" style="margin-right: 8px; vertical-align: text-bottom;">
                                <path d="M3 3v18h18M7 16l4-4 4 4 5-5"/>
                            </svg>
                            Period Statistics (${getTimeRangeLabel(currentTimeRange)})
                        </div>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <span class="stat-label">Avg KV-Cache:</span>
                                <span class="stat-value">${statsData.kv_avg.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Max KV-Cache:</span>
                                <span class="stat-value">${statsData.kv_max.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Avg Memory:</span>
                                <span class="stat-value">${statsData.mem_avg.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Max Memory:</span>
                                <span class="stat-value">${statsData.mem_max.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Avg Fragmentation:</span>
                                <span class="stat-value">${(statsData.frag_avg * 100).toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Data Points:</span>
                                <span class="stat-value">${statsData.count}</span>
                            </div>
                        </div>
                    </div>
                    ` : ''}
                    ${costs ? `
                    <div class="cost-summary">
                        <div class="cost-header">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="margin-right: 8px;">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.31-8.86c-1.77-.45-2.34-.94-2.34-1.67 0-.84.79-1.43 2.1-1.43 1.38 0 1.9.66 1.94 1.64h1.71c-.05-1.34-.87-2.57-2.49-2.97V5H10.9v1.69c-1.51.32-2.72 1.3-2.72 2.81 0 1.79 1.49 2.69 3.66 3.21 1.95.46 2.34 1.15 2.34 1.87 0 .53-.39 1.39-2.1 1.39-1.6 0-2.23-.72-2.32-1.64H8.04c.1 1.7 1.36 2.66 2.86 2.97V19h2.34v-1.67c1.52-.29 2.72-1.16 2.73-2.77-.01-2.2-1.9-2.96-3.66-3.42z"/>
                            </svg>
                            Cost Estimation (${getTimeRangeLabel(currentTimeRange)}) - Block: ${costs.blockSizeMB} MB
                        </div>
                        <div class="cost-grid">
                            <div class="cost-item">
                                <div class="cost-label">Total Cost (Period)</div>
                                <div class="cost-value">$${costs.totalCostForPeriod.toFixed(4)}</div>
                                <div class="cost-subtext">Monthly: $${costs.totalCostPerMonth.toFixed(2)} (${costs.totalGB.toFixed(1)} GB VRAM)</div>
                            </div>
                            <div class="cost-item ${costs.totalWastePerMonth > costs.totalCostPerMonth * 0.2 ? 'cost-warning' : ''}">
                                <div class="cost-label">Total Waste (Period)</div>
                                <div class="cost-value">$${costs.totalWasteCostForPeriod.toFixed(4)}</div>
                                <div class="cost-subtext">Monthly: $${costs.totalWastePerMonth.toFixed(2)} (${((costs.totalWastePerMonth/costs.totalCostPerMonth)*100).toFixed(1)}% of cost)</div>
                            </div>
                            <div class="cost-item ${costs.utilizationPercent > 80 ? 'cost-good' : costs.utilizationPercent < 50 ? 'cost-warning' : ''}">
                                <div class="cost-label">Memory Utilization</div>
                                <div class="cost-value">${costs.utilizationPercent.toFixed(1)}%</div>
                                <div class="cost-subtext">Avg: ${costs.avgUsedGB.toFixed(1)} GB used, ${costs.avgUnusedGB.toFixed(1)} GB idle</div>
                            </div>
                            <div class="cost-item ${costs.kvEfficiencyPercent > 80 ? 'cost-good' : costs.kvEfficiencyPercent < 50 ? 'cost-warning' : ''}">
                                <div class="cost-label">KV-Cache Efficiency</div>
                                <div class="cost-value">${costs.kvEfficiencyPercent.toFixed(1)}%</div>
                                <div class="cost-subtext">Allocated: ${costs.avgKvCacheAllocatedGB.toFixed(1)} GB, Wasted: ${costs.avgKvCacheWastedGB.toFixed(1)} GB</div>
                            </div>
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;

            const chartsHtml = metrics.map(m => `
                <div class="chart-box">
                    <h3>${m.title}</h3>
                    <div class="chart-container">
                        <canvas id="detail-${m.key}"></canvas>
                    </div>
                </div>
            `).join('');

            const chatHtml = `
                <div class="detail-chat">
                    <div class="detail-chat-header">
                        <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" style="margin-right: 8px;">
                            <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/>
                        </svg>
                        Ask AI about this node
                    </div>
                    <div class="detail-chat-suggestions">
                        <button class="suggestion-btn" onclick="askDetailQuestion('Analyze this node performance')">
                            Performance Analysis
                        </button>
                        <button class="suggestion-btn" onclick="askDetailQuestion('What optimizations do you recommend?')">
                            Optimization Tips
                        </button>
                        <button class="suggestion-btn" onclick="askDetailQuestion('Explain the current metrics')">
                            Explain Metrics
                        </button>
                    </div>
                    <div class="detail-chat-body" id="detailChatBody">
                        <div class="chat-message assistant">
                            <div class="chat-bubble">
                                Ask me anything about ${nodeName}'s performance, KV-cache utilization, or get recommendations!
                            </div>
                        </div>
                    </div>
                    <div class="detail-chat-input-container">
                        <input
                            type="text"
                            class="chat-input"
                            id="detailChatInput"
                            placeholder="Ask about this node..."
                            onkeypress="if(event.key==='Enter') sendDetailMessage()"
                        >
                        <button class="chat-send-btn" id="detailChatSendBtn" onclick="sendDetailMessage()">➤</button>
                    </div>
                </div>
            `;

            document.getElementById('detailContent').innerHTML = controls + '<div class="charts-grid">' + chartsHtml + '</div>' + chatHtml;

            console.log(`[openDetail] Fetching timeseries for ${metrics.length} metrics...`);

            for (const m of metrics) {
                const data = await fetchTimeseries(nodeId, m.key, currentTimeRange);
                console.log(`[openDetail] Got ${data.length} points for ${m.key}, creating chart...`);
                createDetailChart(`detail-${m.key}`, data, m.color, currentTimeRange);
            }

            console.log(`[openDetail] All charts created`);

            // Start auto-refresh for detail charts
            startDetailRefresh(nodeId, metrics);
        }

        function startDetailRefresh(nodeId, metrics) {
            // Clear any existing timer
            if (detailRefreshTimer) {
                clearInterval(detailRefreshTimer);
            }

            // Refresh charts and stats every 5 seconds
            detailRefreshTimer = setInterval(async () => {
                console.log(`[detailRefresh] Updating charts and stats for node ${nodeId}`);

                // Update stats summary
                const statsData = await fetchNodeStats(nodeId, currentTimeRange);
                if (statsData) {
                    const statsContainer = document.querySelector('.stats-summary');
                    if (statsContainer) {
                        statsContainer.innerHTML = `
                            <div class="stats-header">
                                <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" style="margin-right: 8px; vertical-align: text-bottom;">
                                    <path d="M3 3v18h18M7 16l4-4 4 4 5-5"/>
                                </svg>
                                Period Statistics (${getTimeRangeLabel(currentTimeRange)})
                            </div>
                            <div class="stats-grid">
                                <div class="stat-item">
                                    <span class="stat-label">Avg KV-Cache:</span>
                                    <span class="stat-value">${statsData.kv_avg.toFixed(2)}%</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Max KV-Cache:</span>
                                    <span class="stat-value">${statsData.kv_max.toFixed(2)}%</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Avg Memory:</span>
                                    <span class="stat-value">${statsData.mem_avg.toFixed(2)}%</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Max Memory:</span>
                                    <span class="stat-value">${statsData.mem_max.toFixed(2)}%</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Avg Fragmentation:</span>
                                    <span class="stat-value">${(statsData.frag_avg * 100).toFixed(2)}%</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Data Points:</span>
                                    <span class="stat-value">${statsData.count}</span>
                                </div>
                            </div>
                        `;
                    }
                }

                // Update cost summary
                const costs = await calculateCosts(nodeId, currentTimeRange);
                if (costs) {
                    const costContainer = document.querySelector('.cost-summary');
                    if (costContainer) {
                        costContainer.innerHTML = `
                            <div class="cost-header">
                                <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="margin-right: 8px;">
                                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.31-8.86c-1.77-.45-2.34-.94-2.34-1.67 0-.84.79-1.43 2.1-1.43 1.38 0 1.9.66 1.94 1.64h1.71c-.05-1.34-.87-2.57-2.49-2.97V5H10.9v1.69c-1.51.32-2.72 1.3-2.72 2.81 0 1.79 1.49 2.69 3.66 3.21 1.95.46 2.34 1.15 2.34 1.87 0 .53-.39 1.39-2.1 1.39-1.6 0-2.23-.72-2.32-1.64H8.04c.1 1.7 1.36 2.66 2.86 2.97V19h2.34v-1.67c1.52-.29 2.72-1.16 2.73-2.77-.01-2.2-1.9-2.96-3.66-3.42z"/>
                                </svg>
                                Cost Estimation (${getTimeRangeLabel(currentTimeRange)}) - Block: ${costs.blockSizeMB} MB
                            </div>
                            <div class="cost-grid">
                                <div class="cost-item">
                                    <div class="cost-label">Total Cost (Period)</div>
                                    <div class="cost-value">$${costs.totalCostForPeriod.toFixed(4)}</div>
                                    <div class="cost-subtext">Monthly: $${costs.totalCostPerMonth.toFixed(2)} (${costs.totalGB.toFixed(1)} GB VRAM)</div>
                                </div>
                                <div class="cost-item ${costs.totalWastePerMonth > costs.totalCostPerMonth * 0.2 ? 'cost-warning' : ''}">
                                    <div class="cost-label">Total Waste (Period)</div>
                                    <div class="cost-value">$${costs.totalWasteCostForPeriod.toFixed(4)}</div>
                                    <div class="cost-subtext">Monthly: $${costs.totalWastePerMonth.toFixed(2)} (${((costs.totalWastePerMonth/costs.totalCostPerMonth)*100).toFixed(1)}% of cost)</div>
                                </div>
                                <div class="cost-item ${costs.utilizationPercent > 80 ? 'cost-good' : costs.utilizationPercent < 50 ? 'cost-warning' : ''}">
                                    <div class="cost-label">Memory Utilization</div>
                                    <div class="cost-value">${costs.utilizationPercent.toFixed(1)}%</div>
                                    <div class="cost-subtext">Avg: ${costs.avgUsedGB.toFixed(1)} GB used, ${costs.avgUnusedGB.toFixed(1)} GB idle</div>
                                </div>
                                <div class="cost-item ${costs.kvEfficiencyPercent > 80 ? 'cost-good' : costs.kvEfficiencyPercent < 50 ? 'cost-warning' : ''}">
                                    <div class="cost-label">KV-Cache Efficiency</div>
                                    <div class="cost-value">${costs.kvEfficiencyPercent.toFixed(1)}%</div>
                                    <div class="cost-subtext">Allocated: ${costs.avgKvCacheAllocatedGB.toFixed(1)} GB, Wasted: ${costs.avgKvCacheWastedGB.toFixed(1)} GB</div>
                                </div>
                            </div>
                        `;
                    }
                }

                // Update charts
                for (const m of metrics) {
                    const data = await fetchTimeseries(nodeId, m.key, currentTimeRange);
                    updateDetailChart(`detail-${m.key}`, data, m.color, currentTimeRange);
                }
            }, REFRESH_INTERVAL);
        }

        async function changeTimeRange(duration) {
            if (!currentNode) return;

            currentTimeRange = duration;
            console.log(`[changeTimeRange] Changed to ${duration}s (${duration/3600}h)`);

            // Re-fetch data and update all charts
            const nodeId = currentNode.id;
            const metrics = [
                { key: 'kv_cache_utilization', title: 'KV-Cache Utilization (%)', color: getCSSVar('--chart-line-1') },
                { key: 'vllm_memory_utilization', title: 'vLLM Memory Utilization (%)', color: getCSSVar('--chart-line-2') },
                { key: 'allocated_blocks', title: 'Allocated Blocks (Total)', color: getCSSVar('--chart-line-1') },
                { key: 'utilized_blocks', title: 'Utilized Blocks (In Use)', color: getCSSVar('--chart-line-3') },
                { key: 'memory_fragmentation', title: 'Memory Fragmentation', color: getCSSVar('--chart-line-4') },
                { key: 'used_bytes', title: 'Used Memory (Bytes)', color: getCSSVar('--chart-line-5') },
                { key: 'num_processes', title: 'Number of Processes', color: getCSSVar('--chart-line-6') }
            ];

            // Update button states
            document.querySelectorAll('.time-range-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Reload stats summary with new time range
            const statsData = await fetchNodeStats(nodeId, currentTimeRange);
            if (statsData) {
                const statsContainer = document.querySelector('.stats-summary');
                if (statsContainer) {
                    statsContainer.innerHTML = `
                        <div class="stats-header">
                            <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor" style="margin-right: 8px; vertical-align: text-bottom;">
                                <path d="M3 3v18h18M7 16l4-4 4 4 5-5"/>
                            </svg>
                            Period Statistics (${getTimeRangeLabel(currentTimeRange)})
                        </div>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <span class="stat-label">Avg KV-Cache:</span>
                                <span class="stat-value">${statsData.kv_avg.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Max KV-Cache:</span>
                                <span class="stat-value">${statsData.kv_max.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Avg Memory:</span>
                                <span class="stat-value">${statsData.mem_avg.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Max Memory:</span>
                                <span class="stat-value">${statsData.mem_max.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Avg Fragmentation:</span>
                                <span class="stat-value">${(statsData.frag_avg * 100).toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Data Points:</span>
                                <span class="stat-value">${statsData.count}</span>
                            </div>
                        </div>
                    `;
                }
            }

            // Reload cost summary with new time range
            const costs = await calculateCosts(nodeId, currentTimeRange);
            if (costs) {
                const costContainer = document.querySelector('.cost-summary');
                if (costContainer) {
                    costContainer.innerHTML = `
                        <div class="cost-header">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="margin-right: 8px;">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.31-8.86c-1.77-.45-2.34-.94-2.34-1.67 0-.84.79-1.43 2.1-1.43 1.38 0 1.9.66 1.94 1.64h1.71c-.05-1.34-.87-2.57-2.49-2.97V5H10.9v1.69c-1.51.32-2.72 1.3-2.72 2.81 0 1.79 1.49 2.69 3.66 3.21 1.95.46 2.34 1.15 2.34 1.87 0 .53-.39 1.39-2.1 1.39-1.6 0-2.23-.72-2.32-1.64H8.04c.1 1.7 1.36 2.66 2.86 2.97V19h2.34v-1.67c1.52-.29 2.72-1.16 2.73-2.77-.01-2.2-1.9-2.96-3.66-3.42z"/>
                            </svg>
                            Cost Estimation (${getTimeRangeLabel(currentTimeRange)}) - Block: ${costs.blockSizeMB} MB
                        </div>
                        <div class="cost-grid">
                            <div class="cost-item">
                                <div class="cost-label">Total Cost (Period)</div>
                                <div class="cost-value">$${costs.totalCostForPeriod.toFixed(4)}</div>
                                <div class="cost-subtext">Monthly: $${costs.totalCostPerMonth.toFixed(2)} (${costs.totalGB.toFixed(1)} GB VRAM)</div>
                            </div>
                            <div class="cost-item ${costs.totalWastePerMonth > costs.totalCostPerMonth * 0.2 ? 'cost-warning' : ''}">
                                <div class="cost-label">Total Waste (Period)</div>
                                <div class="cost-value">$${costs.totalWasteCostForPeriod.toFixed(4)}</div>
                                <div class="cost-subtext">Monthly: $${costs.totalWastePerMonth.toFixed(2)} (${((costs.totalWastePerMonth/costs.totalCostPerMonth)*100).toFixed(1)}% of cost)</div>
                            </div>
                            <div class="cost-item ${costs.utilizationPercent > 80 ? 'cost-good' : costs.utilizationPercent < 50 ? 'cost-warning' : ''}">
                                <div class="cost-label">Memory Utilization</div>
                                <div class="cost-value">${costs.utilizationPercent.toFixed(1)}%</div>
                                <div class="cost-subtext">Avg: ${costs.avgUsedGB.toFixed(1)} GB used, ${costs.avgUnusedGB.toFixed(1)} GB idle</div>
                            </div>
                            <div class="cost-item ${costs.kvEfficiencyPercent > 80 ? 'cost-good' : costs.kvEfficiencyPercent < 50 ? 'cost-warning' : ''}">
                                <div class="cost-label">KV-Cache Efficiency</div>
                                <div class="cost-value">${costs.kvEfficiencyPercent.toFixed(1)}%</div>
                                <div class="cost-subtext">Allocated: ${costs.avgKvCacheAllocatedGB.toFixed(1)} GB, Wasted: ${costs.avgKvCacheWastedGB.toFixed(1)} GB</div>
                            </div>
                        </div>
                    `;
                }
            }

            // Reload all charts with new time range
            for (const m of metrics) {
                const data = await fetchTimeseries(nodeId, m.key, currentTimeRange);
                createDetailChart(`detail-${m.key}`, data, m.color, currentTimeRange);
            }

            // Restart auto-refresh with new time range
            startDetailRefresh(nodeId, metrics);
        }

        function createDetailChart(canvasId, data, color, duration = currentTimeRange) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.warn(`[createDetailChart] Canvas not found: ${canvasId}`);
                return;
            }

            if (detailCharts[canvasId]) {
                detailCharts[canvasId].destroy();
            }

            console.log(`[createDetailChart] ${canvasId}: Creating chart with ${data.length} points for ${duration}s range`);

            const now = new Date();
            const startTime = new Date(now - duration * 1000);

            // Determine appropriate time unit based on duration
            let timeUnit = 'minute';
            let displayFormat = 'HH:mm';

            if (duration > 86400) { // > 1 day
                timeUnit = 'day';
                displayFormat = 'MMM dd';
            } else if (duration > 7200) { // > 2 hours
                timeUnit = 'hour';
                displayFormat = 'HH:mm';
            } else if (duration <= 600) { // <= 10 minutes
                timeUnit = 'minute';
                displayFormat = 'HH:mm:ss';
            }

            const chartData = {
                labels: data.map(d => new Date(d.timestamp)),
                datasets: [{
                    data: data.map(d => d.value),
                    borderColor: color,
                    backgroundColor: color + '33',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    pointRadius: data.length > 100 ? 0 : 2  // Hide points if too many
                }]
            };

            console.log(`[createDetailChart] ${canvasId}: Chart has ${chartData.labels.length} labels and ${chartData.datasets[0].data.length} data points`);

            const gridColor = getCSSVar('--chart-grid');
            const textColor = getCSSVar('--chart-text');

            detailCharts[canvasId] = new Chart(canvas, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { mode: 'index', intersect: false }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: startTime,
                            max: now,
                            time: {
                                unit: timeUnit,
                                displayFormats: {
                                    second: 'HH:mm:ss',
                                    minute: displayFormat,
                                    hour: 'HH:mm',
                                    day: 'MMM dd'
                                }
                            },
                            grid: { color: gridColor },
                            ticks: { color: textColor }
                        },
                        y: {
                            beginAtZero: true,
                            grid: { color: gridColor },
                            ticks: { color: textColor }
                        }
                    }
                }
            });
        }

        function updateDetailChart(canvasId, data, color, duration = currentTimeRange) {
            const chart = detailCharts[canvasId];
            if (!chart) {
                console.warn(`[updateDetailChart] Chart not found: ${canvasId}, creating new one`);
                createDetailChart(canvasId, data, color, duration);
                return;
            }

            const now = new Date();
            const startTime = new Date(now - duration * 1000);

            // Update data
            chart.data.labels = data.map(d => new Date(d.timestamp));
            chart.data.datasets[0].data = data.map(d => d.value);
            chart.data.datasets[0].pointRadius = data.length > 100 ? 0 : 2;

            // Update time axis
            chart.options.scales.x.min = startTime;
            chart.options.scales.x.max = now;

            // Update chart without animation for smoother updates
            chart.update('none');

            // Brief visual feedback on update
            const canvas = chart.canvas;
            if (canvas && canvas.parentElement) {
                canvas.parentElement.style.opacity = '0.7';
                setTimeout(() => {
                    canvas.parentElement.style.opacity = '1';
                }, 100);
            }
        }

        function closeDetailModal() {
            document.getElementById('detailModal').classList.remove('active');

            // Stop auto-refresh
            if (detailRefreshTimer) {
                clearInterval(detailRefreshTimer);
                detailRefreshTimer = null;
            }

            Object.values(detailCharts).forEach(c => c.destroy());
            detailCharts = {};
            currentNode = null;
            currentTimeRange = 3600; // Reset to default 1 hour
        }

        // === NODE ACTIONS ===
        async function toggleNode() {
            if (!currentNode) return;
            const newState = !currentNode.enabled;
            const res = await fetch(`${API_BASE}/nodes/${currentNode.id}?enabled=${newState}`, { method: 'PUT' });
            if (res.ok) {
                closeDetailModal();
                updateDashboard();
                showMessage(`Node ${newState ? 'enabled' : 'disabled'} successfully`, 'success');
            } else {
                showMessage('Failed to toggle node');
            }
        }

        async function editNode() {
            if (!currentNode) return;
            const name = prompt('Node Name:', currentNode.name);
            if (!name) return;
            const host = prompt('Host:', currentNode.host);
            if (!host) return;
            const port = prompt('Port:', currentNode.port);
            if (!port) return;

            const res = await fetch(`${API_BASE}/nodes/${currentNode.id}?name=${encodeURIComponent(name)}&host=${encodeURIComponent(host)}&port=${port}`, { method: 'PUT' });
            if (res.ok) {
                closeDetailModal();
                updateDashboard();
                showMessage('Node updated successfully', 'success');
            } else {
                showMessage('Failed to update node');
            }
        }

        async function deleteNode() {
            if (!currentNode) return;
            if (!confirm(`Delete "${currentNode.name}"?\n\nThis will delete all data and cannot be undone.`)) return;

            const res = await fetch(`${API_BASE}/nodes/${currentNode.id}`, { method: 'DELETE' });
            if (res.ok) {
                closeDetailModal();
                updateDashboard();
                showMessage('Node deleted successfully', 'success');
            } else {
                showMessage('Failed to delete node');
            }
        }

        // === ADD NODE ===
        function openAddModal() {
            document.getElementById('addNodeModal').classList.add('active');
            document.getElementById('nodeName').value = '';
            document.getElementById('nodeHost').value = '';
            document.getElementById('nodePort').value = '6767';
            document.getElementById('add-message').innerHTML = '';
        }

        function closeAddModal() {
            document.getElementById('addNodeModal').classList.remove('active');
        }

        async function handleAddNode(e) {
            e.preventDefault();
            const name = document.getElementById('nodeName').value.trim();
            const host = document.getElementById('nodeHost').value.trim();
            const port = parseInt(document.getElementById('nodePort').value);

            const res = await fetch(`${API_BASE}/nodes`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, host, port })
            });

            if (res.ok) {
                document.getElementById('add-message').innerHTML = `<div class="message success">Node "${name}" added!</div>`;
                setTimeout(() => {
                    closeAddModal();
                    updateDashboard();
                }, 1500);
            } else {
                const err = await res.json();
                document.getElementById('add-message').innerHTML = `<div class="message error">${err.detail || 'Failed to add node'}</div>`;
            }
        }

        // === CHAT INTERFACE ===
        let selectedNodeIds = [];  // Empty means all nodes
        let chatMinimized = false;

        function toggleChat() {
            const container = document.getElementById('chatContainer');
            const btn = document.getElementById('chatToggleBtn');
            chatMinimized = !chatMinimized;

            if (chatMinimized) {
                container.classList.add('minimized');
                btn.textContent = '+';
            } else {
                container.classList.remove('minimized');
                btn.textContent = '−';
            }
        }

        function updateNodeSelector() {
            const list = document.getElementById('nodeSelectorList');
            if (!nodes || nodes.length === 0) {
                list.innerHTML = '';
                return;
            }

            // Only update if the node list has changed
            const currentNodeIds = nodes.map(n => n.id).sort().join(',');
            const existingNodeIds = Array.from(list.querySelectorAll('input[type="checkbox"]'))
                .map(input => input.value)
                .sort()
                .join(',');

            if (currentNodeIds === existingNodeIds) {
                return; // No changes needed
            }

            // Rebuild node list
            list.innerHTML = nodes.map(node => {
                const isSelected = selectedNodeIds.includes(node.id);
                return `
                    <label class="node-checkbox ${isSelected ? 'selected' : ''}" id="node-check-${node.id}">
                        <input type="checkbox" value="${node.id}" ${isSelected ? 'checked' : ''} onchange="toggleNodeSelection(${node.id}, this)">
                        ${node.name}
                    </label>
                `;
            }).join('');
        }

        function updateSelectionCount() {
            const countEl = document.getElementById('nodeSelectionCount');
            if (selectedNodeIds.length === 0) {
                countEl.style.display = 'none';
            } else {
                const totalEnabled = nodes.filter(n => n.enabled).length;
                countEl.textContent = `${selectedNodeIds.length} of ${totalEnabled} nodes`;
                countEl.style.display = 'block';
            }
        }

        function toggleAllNodes(checkbox) {
            const allCheckbox = document.getElementById('allNodesCheckbox');
            const nodeCheckboxes = document.querySelectorAll('#nodeSelectorList input[type="checkbox"]');

            if (checkbox.checked) {
                // "All Nodes" selected - clear individual selections
                allCheckbox.classList.add('selected');
                selectedNodeIds = [];
                nodeCheckboxes.forEach(cb => {
                    cb.checked = false;
                    cb.parentElement.classList.remove('selected');
                });
                updateSelectionCount();
                console.log('[Node Selector] All nodes selected');
            } else {
                // User unchecked "All Nodes" - they must select at least one individual node
                // Don't allow unchecking if no nodes are selected
                if (selectedNodeIds.length === 0) {
                    checkbox.checked = true;
                    allCheckbox.classList.add('selected');
                    console.log('[Node Selector] Cannot uncheck "All Nodes" without selecting individual nodes');
                } else {
                    allCheckbox.classList.remove('selected');
                    updateSelectionCount();
                }
            }
        }

        function toggleNodeSelection(nodeId, checkbox) {
            const allCheckbox = document.getElementById('allNodesCheckbox');
            const allCheckboxInput = allCheckbox.querySelector('input');
            const nodeCheckbox = document.getElementById(`node-check-${nodeId}`);

            if (checkbox.checked) {
                // Add node to selection
                if (!selectedNodeIds.includes(nodeId)) {
                    selectedNodeIds.push(nodeId);
                }
                nodeCheckbox.classList.add('selected');

                // Uncheck "All Nodes"
                allCheckboxInput.checked = false;
                allCheckbox.classList.remove('selected');

                updateSelectionCount();
                console.log(`[Node Selector] Selected nodes: ${selectedNodeIds.join(', ')}`);
            } else {
                // Remove node from selection
                selectedNodeIds = selectedNodeIds.filter(id => id !== nodeId);
                nodeCheckbox.classList.remove('selected');

                // If no nodes selected, revert to "All Nodes"
                if (selectedNodeIds.length === 0) {
                    allCheckboxInput.checked = true;
                    allCheckbox.classList.add('selected');
                    console.log('[Node Selector] No nodes selected, reverting to All Nodes');
                } else {
                    console.log(`[Node Selector] Selected nodes: ${selectedNodeIds.join(', ')}`);
                }

                updateSelectionCount();
            }
        }

        function addChatMessage(message, isUser = false) {
            const chatBody = document.getElementById('chatBody');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isUser ? 'user' : 'assistant'}`;

            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble';
            bubble.textContent = message;

            messageDiv.appendChild(bubble);
            chatBody.appendChild(messageDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
        }

        function showChatLoading() {
            const chatBody = document.getElementById('chatBody');
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'chat-message assistant';
            loadingDiv.id = 'chat-loading';
            loadingDiv.innerHTML = `
                <div class="chat-loading">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            `;
            chatBody.appendChild(loadingDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
        }

        function removeChatLoading() {
            const loading = document.getElementById('chat-loading');
            if (loading) loading.remove();
        }

        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const sendBtn = document.getElementById('chatSendBtn');
            const message = input.value.trim();

            if (!message) return;

            // Add user message
            addChatMessage(message, true);
            input.value = '';

            // Disable input while processing
            input.disabled = true;
            sendBtn.disabled = true;
            showChatLoading();

            try {
                const response = await fetch(`${API_BASE}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: message,
                        node_ids: selectedNodeIds.length > 0 ? selectedNodeIds : null
                    })
                });

                removeChatLoading();

                if (response.ok) {
                    const data = await response.json();
                    addChatMessage(data.response, false);
                } else {
                    const error = await response.json();
                    addChatMessage(`Error: ${error.detail || 'Failed to get response'}`, false);
                }
            } catch (error) {
                removeChatLoading();
                addChatMessage(`Error: ${error.message}. Make sure Claude API key is set in .env file.`, false);
            } finally {
                input.disabled = false;
                sendBtn.disabled = false;
                input.focus();
            }
        }

        function askQuestion(question) {
            const input = document.getElementById('chatInput');
            input.value = question;
            sendMessage();
        }

        // Detail modal chat functions
        function addDetailChatMessage(message, isUser = false) {
            const chatBody = document.getElementById('detailChatBody');
            if (!chatBody) return;

            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isUser ? 'user' : 'assistant'}`;

            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble';
            bubble.textContent = message;

            messageDiv.appendChild(bubble);
            chatBody.appendChild(messageDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
        }

        function showDetailChatLoading() {
            const chatBody = document.getElementById('detailChatBody');
            if (!chatBody) return;

            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'chat-message assistant';
            loadingDiv.id = 'detail-chat-loading';
            loadingDiv.innerHTML = `
                <div class="chat-loading">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            `;
            chatBody.appendChild(loadingDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
        }

        function removeDetailChatLoading() {
            const loading = document.getElementById('detail-chat-loading');
            if (loading) loading.remove();
        }

        async function sendDetailMessage() {
            if (!currentNode) return;

            const input = document.getElementById('detailChatInput');
            const sendBtn = document.getElementById('detailChatSendBtn');
            const message = input.value.trim();

            if (!message) return;

            // Add user message
            addDetailChatMessage(message, true);
            input.value = '';

            // Disable input while processing
            input.disabled = true;
            sendBtn.disabled = true;
            showDetailChatLoading();

            try {
                const response = await fetch(`${API_BASE}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: message,
                        node_ids: [currentNode.id]
                    })
                });

                removeDetailChatLoading();

                if (response.ok) {
                    const data = await response.json();
                    addDetailChatMessage(data.response, false);
                } else {
                    const error = await response.json();
                    addDetailChatMessage(`Error: ${error.detail || 'Failed to get response'}`, false);
                }
            } catch (error) {
                removeDetailChatLoading();
                addDetailChatMessage(`Error: ${error.message}. Make sure Claude API key is set in .env file.`, false);
            } finally {
                input.disabled = false;
                sendBtn.disabled = false;
                input.focus();
            }
        }

        function askDetailQuestion(question) {
            const input = document.getElementById('detailChatInput');
            if (input) {
                input.value = question;
                sendDetailMessage();
            }
        }

        // === INIT ===
        updateDashboard();
        refreshTimer = setInterval(updateDashboard, REFRESH_INTERVAL);

        // Update node selector periodically
        setInterval(updateNodeSelector, REFRESH_INTERVAL);

        document.getElementById('addNodeModal').addEventListener('click', e => {
            if (e.target.id === 'addNodeModal') closeAddModal();
        });
        document.getElementById('detailModal').addEventListener('click', e => {
            if (e.target.id === 'detailModal') closeDetailModal();
        });
    </script>
</body>
</html>
